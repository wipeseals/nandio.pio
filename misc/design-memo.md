# **MicroPython を用いた RP2040 搭載 JISC-SSD ボードにおける Flash Translation Layer 実装の技術的検討**

(This reports created by Gemini 2.5 Pro (Preview))

## **I. エグゼクティブサマリー**

本報告書は、RP2040 マイクロコントローラと Kioxia 製 NAND フラッシュメモリを搭載した JISC-SSD ボード上で、MicroPython を用いた Flash Translation Layer (FTL) の実装に関する技術的な実現可能性と実装戦略を詳細に検討するものである。リソースが限られた JISC-SSD において MicroPython で FTL を実装するという課題の中核は、性能要求を満たすために C 言語による拡張モジュールが不可欠である点にある。RP2040 の PIO (Programmable I/O) は NAND 制御に適しており、ホスト側での ECC (Error Correction Code) 処理は必須である。主要な推奨 FTL アプローチとしては、既存の Dhara FTL の適用、または慎重に設計されたカスタムソリューションが考えられる。Kioxia 製 NAND の特性と JISC-SSD のアーキテクチャに関する主要な分析結果も本報告書には含まれる。

このプロジェクトの成功は、MicroPython の高レベルなロジック管理能力と、C 言語モジュールによる低レベル NAND 制御、ECC 処理、および FTL コアアルゴリズムの高性能な実行を組み合わせたハイブリッドアプローチにかかっている。FTL アルゴリズム（ウェアレベリング、ガベージコレクション、ECC など）は複雑で I/O 集約的であり <sup>1</sup>、NAND フラッシュ操作はタイミングに敏感で低レベルのハードウェア対話を含む <sup>3</sup>。MicroPython はインタプリタ言語であるため、このようなタスクに対して C 言語と比較して本質的な性能オーバーヘッドがあり <sup>4</sup>、RP2040 のリソースは限られている <sup>5</sup>。したがって、純粋な MicroPython による FTL は実用的ではない可能性が高く、C 言語拡張モジュールの活用が性能最適化のためだけでなく、基本的な実現可能性のために不可欠となる。

FTL 戦略の選択は、RP2040 の制約内で ECC を実装し、RAW NAND の複雑性を管理する必要性に大きく影響される。JISC-SSD に搭載されている Kioxia TC58NVG0S3HTA00 は RAW NAND であり、ホスト側での 8 ビット/512 バイトの ECC 処理と完全な FTL 管理を必要とする <sup>3</sup>。堅牢な ECC（BCH など）と FTL 機能（不良ブロック管理、ウェアレベリング、ガベージコレクション）の実装は容易ではない <sup>1</sup>。既存の FTL である Dhara は RAW NAND 向けに設計されているが、カスタム HAL (Hardware Abstraction Layer) が必要であり <sup>7</sup>、LittleFS は ECC と大きな消去ブロックへの対応なしに RAW NAND に直接使用するには適していない <sup>9</sup>。したがって、FTL ソリューションは ECC を効率的に統合し、NAND の全ての複雑な側面を管理しなければならない。これは、既存 FTL（Dhara と新規 HAL など）の大幅な改変、または慎重に設計されたカスタム FTL への選択を促す。

## **II. NAND メモリ向け Flash Translation Layer の基礎**

NAND フラッシュメモリの効率的かつ信頼性の高い利用には、Flash Translation Layer (FTL) と呼ばれるソフトウェア層が不可欠である。FTL は、オペレーティングシステムやファイルシステムに対してシンプルな論理ブロックインターフェースを提供しつつ、NAND フラッシュ固有の複雑な物理特性を管理する <sup>1</sup>。

### **A. FTL の主要な責務：ウェアレベリング、不良ブロック管理、ガベージコレクション**

FTL は主に、ウェアレベリング、不良ブロック管理、ガベージコレクションという 3 つの重要な機能を通じて NAND フラッシュの寿命と信頼性を最大化する。

- ウェアレベリング (Wear Leveling): \
  NAND フラッシュセルは、書き込み/消去サイクル数に上限があり、それを超えると信頼性が低下する（消耗する）1。ウェアレベリングは、特定のブロックが他のブロックに比べて過度に使用されるのを防ぐために、データの書き込みを物理ブロック間で均等に分散させるアルゴリズムである 10。これにより、チップ全体の寿命を最大限に延ばすことができる。FTL は、動的ウェアレベリング（空きブロックの中から最も消去回数の少ないブロックを選択して書き込む）や静的ウェアレベリング（データが書き込まれているブロックも含めて、消去回数が少ないブロックのデータを移動させる）などの手法を用いる 10。
- 不良ブロック管理 (Bad Block Management): \
  NAND フラッシュメモリには、製造時から存在する初期不良ブロックや、動作中に書き込み/消去サイクルの繰り返しによって発生する後発不良ブロックが含まれる可能性がある 1。FTL はこれらの不良ブロックを検出し、マークを付け、使用しないように管理する 13。不良ブロックが検出されると、予約された代替ブロックが使用され、データの損失を防ぎ、製品の信頼性を高める 12。
- ガベージコレクション (Garbage Collection): \
  NAND フラッシュメモリは、データを直接上書きすることができず、新しいデータを書き込む前にブロック単位で消去する必要があるという特性を持つ 2。データが更新または削除されると、元のデータが保存されていたページは無効となる。ガベージコレクションは、部分的に有効なデータが含まれるブロックから有効なデータのみを新しいブロックに集約し、元のブロックを消去して再利用可能な状態にするプロセスである 2。これにより、書き込み性能の低下を防ぎ、空き容量を確保する。

これら 3 つの FTL コンポーネントは深く相互に関連しており、その効率的な連携が性能と耐久性の両方にとって極めて重要である。例えば、ウェアレベリングはデータを移動させて摩耗を分散させるが <sup>10</sup>、このデータ移動によって以前のブロック内のページが無効になることがある。その結果、これらの無効データを含むブロックを再利用するためにガベージコレクションが必要となる <sup>2</sup>。不良ブロック管理は、ウェアレベリングやガベージコレクションが欠陥のあるブロックを使用したり、データを移動したりしないように保証する <sup>12</sup>。したがって、FTL の設計ではこれらの相互作用を総合的に考慮しなければならない。例えば、積極的なウェアレベリング戦略は、より頻繁なガベージコレクションを引き起こし、パフォーマンスに影響を与える可能性がある。

### **B. 論理-物理アドレスマッピング**

FTL の基本的な機能の一つは、ホスト（オペレーティングシステムやファイルシステム）に対して、NAND フラッシュの物理的な複雑さ（ブロックやページ構造、不良ブロックの存在など）を隠蔽し、線形的で連続した論理ブロックアドレス（LBA）空間を提供することである <sup>1</sup>。FTL は、この LBA を NAND フラッシュメモリ上の実際の物理ページアドレス（PPA）に変換するためのマッピングテーブルを内部で維持・管理する。

マッピングの粒度には、ページ単位マッピング、ブロック単位マッピング、ハイブリッドマッピングなど、いくつかの方式が存在する <sup>16</sup>。

- **ページ単位マッピング:** 各論理ページを直接物理ページに対応付ける。高い柔軟性と性能が得られるが、マッピングテーブルが非常に大きくなり、特にリソースの限られた組み込みシステムでは RAM 容量を圧迫する可能性がある。
- **ブロック単位マッピング:** 論理ブロックを物理ブロックに対応付け、ブロック内のページオフセットは一致させる。マッピングテーブルは小さく済むが、ブロック内でデータが断片化しやすく、ガベージコレクション時に有効なページを移動させるオーバーヘッドが大きくなる傾向がある。
- **ハイブリッドマッピング:** 上記 2 つの方式を組み合わせたもので、例えばデータブロックの大部分はブロック単位でマッピングし、頻繁に更新される少量のデータはページ単位でログブロックに書き込むといった手法がある。性能と RAM 使用量のバランスを取ろうとするが、制御が複雑になる。

RP2040 のようなリソースが制約されたシステムにとって、マッピング粒度の選択は極めて重要な設計判断となる。ページ単位マッピングは高性能だが、RP2040 の SRAM（264KB <sup>17</sup>）にはマッピングテーブル全体を格納するには大きすぎる可能性がある <sup>6</sup>。ブロック単位マッピングはテーブルサイズは小さいものの、性能問題を引き起こしやすい <sup>16</sup>。JISC-SSD の場合、マッピングテーブルの一部を RAM にキャッシュし、必要に応じて NAND フラッシュからオンデマンドで読み込むページ単位マッピング、あるいは慎重に設計されたハイブリッドアプローチが必要になるだろう。FTL は、このマッピングテーブルを効率的に管理しなければならない。

### **C. エラー訂正符号（ECC）とデータ整合性の重要性**

NAND フラッシュメモリのセルは、読み出しディスターブ（特定のページを繰り返し読み出すことで同じブロック内の他のページにエラーが発生する現象）、プログラムディスターブ（特定のページに書き込むことで隣接するページにエラーが発生する現象）、あるいは単なるセルの経年劣化により、記憶しているビットが反転する可能性がある <sup>1</sup>。このため、NAND フラッシュメモリにおけるデータの信頼性を確保するためには、エラー訂正符号（ECC）が不可欠である <sup>1</sup>。ECC はオプションではなく、必須の機能と言える <sup>3</sup>。

ECC は、データセクター内に発生した一定数のビットエラーを検出し、訂正するメカニズムである。ECC で訂正不可能なエラー（Uncorrectable Error）が発生した場合、FTL はそのブロックを不良ブロックとしてマークし、使用を中止するなどの適切な処置を講じる必要がある。Kioxia 製 NAND フラッシュの場合、ホスト側での ECC 処理が要求される <sup>3</sup>。

Kioxia 製 NAND に対して ECC を正しく実装しない場合、必然的にデータ破損につながる。NAND フラッシュは本質的にビットエラーを起こしやすく <sup>1</sup>、Kioxia TC58NVG0S3HTA00 のデータシートはホスト側での 512 バイトあたり 8 ビットの ECC 処理を明確に要求している <sup>3</sup>。ECC がなければ、これらのビットエラーは検出も訂正もされず、データは静かに破損していく。したがって、ECC は FTL の交渉の余地のない部分であり、システムは NAND から読み書きされるデータの 512 バイトセクターごとに 8 ビット訂正能力を持つ ECC アルゴリズム（BCH など）を実装しなければならない。

## **III. ターゲットハードウェアプラットフォーム：RP2040 と Kioxia NAND を搭載した JISC-SSD**

本検討で対象とするハードウェアは、RP2040 マイクロコントローラと Kioxia 製 TC58NVG0S3HTA00 NAND フラッシュを搭載した JISC-SSD ボードである。

### **A. JISC-SSD ボードアーキテクチャと関連コンポーネント**

JISC-SSD は、ストレージ内コンピューティング（In-Storage Computation）の学習用に設計されたボードであり、主要コンポーネントとして Raspberry Pi RP2040 MCU と Kioxia TC58NVG0S3HTA00 128MByte NAND フラッシュメモリを搭載している <sup>19</sup>。ボードの形状は M.2 規格を意識したデザインだが、M.2 規格に完全に準拠しているわけではない <sup>19</sup>。電源は USB Type-C 端子から供給され、USB 2.0 接続をサポートする <sup>19</sup>。

JISC-SSD は、USB、I2C、UART、GPIO（ADC x2 を含む）といった豊富な I/O 端子を備えており、Raspberry Pi Pico 互換の開発環境（MicroPython、C/C++ SDK）で開発が可能である <sup>19</sup>。NAND フラッシュの制御には、CEB0、CEB1 端子がチップセレクトとして使用されることが示唆されている <sup>19</sup>。

JISC-SSD が「学習ボード」としての性質を持ち、Pico 互換であることは、コミュニティサポートや開発ツールの入手が容易であることを示唆するが、一方で商用 SSD のような極端な I/O 性能に最適化されていない可能性も示唆する。ストレージ内コンピューティングに焦点が当てられていることから、柔軟性が優先されていると考えられる。したがって、本 FTL プロジェクトには適しているものの、RAW NAND スループットに対する期待は、その教育的な設計意図によって調整されるべきである。Pico ツールによる開発の容易さは大きな利点となる。

**表 1：JISC-SSD ボード - FTL 実装のための主要ハードウェア仕様**

<table>
  <tr>
   <td><strong>特徴</strong>
   </td>
   <td><strong>仕様</strong>
   </td>
   <td><strong>出典</strong>
   </td>
  </tr>
  <tr>
   <td>MCU
   </td>
   <td>RP2040 デュアルコア Arm Cortex-M0+
   </td>
   <td><sup>19</sup>
   </td>
  </tr>
  <tr>
   <td>MCUオンボードQSPIフラッシュ
   </td>
   <td>16Mbyte (W25Q128JVSIQ) (MicroPythonランタイムおよびコード用)
   </td>
   <td><sup>19</sup>
   </td>
  </tr>
  <tr>
   <td>外部RAW NANDフラッシュ
   </td>
   <td>Kioxia TC58NVG0S3HTA00, 128 Mbyte
   </td>
   <td><sup>19</sup>
   </td>
  </tr>
  <tr>
   <td>NANDフラッシュインターフェース
   </td>
   <td>パラレル、RP2040 GPIO経由で制御 (チップセレクト用にCEB0,1が言及)
   </td>
   <td><sup>19</sup>
   </td>
  </tr>
  <tr>
   <td>RP2040 SRAM
   </td>
   <td>264KB
   </td>
   <td><sup>17</sup>
   </td>
  </tr>
  <tr>
   <td>開発環境
   </td>
   <td>Raspberry Pi Pico互換 (MicroPython, C/C++)
   </td>
   <td><sup>19</sup>
   </td>
  </tr>
</table>

この表は、FTL 設計が考慮すべきリソース（NAND 容量、SRAM、MCU タイプ）と制約を即座に明確にする。

### **B. RP2040 マイクロコントローラ：FTL への適合性（SRAM、PIO、処理能力）**

RP2040 は、最大 133MHz 以上で動作するデュアル Cortex-M0+コア、264KB の SRAM を搭載し、ユーザーデータ用の内部 NVM（不揮発性メモリ）は持たず、ファームウェアは外部 QSPI フラッシュから実行される <sup>17</sup>。コード実行には QSPI フラッシュからの XIP (eXecute In Place) が利用され、16KB の XIP キャッシュも備えている <sup>6</sup>。

FTL 実装において特に重要な RP2040 の機能は、プログラマブル I/O (PIO) である <sup>17</sup>。PIO は、CPU コアから独立してカスタム I/O インターフェース（パラレル NAND インターフェースなど）を実装できる強力なペリフェラルである <sup>17</sup>。

RP2040 の PIO は、本プロジェクトを可能にする最も重要なアーキテクチャ上の特徴である。PIO がなければ、M0+コアで効率的なパラレル NAND 制御を実現することは極めて困難であっただろう。パラレル NAND は、複数の制御線とデータ線の正確かつ高速な操作を必要とする <sup>3</sup>。CPU、特に M0+コアによる直接のビットバンギングは、かなりの処理能力を消費し、複雑なプロトコルのタイミング精度を維持するのに苦労する可能性がある。RP2040 の PIO は、このような I/O タスクをメインコアからオフロードするために設計されており <sup>17</sup>、PIO ステートマシンは独立して決定論的に GPIO を制御できる <sup>21</sup>。したがって、PIO は単なる便宜機能ではなく、RP2040 上で高性能なパラレル NAND インターフェースを実装するための重要な実現手段である。

一方で、264KB の SRAM は、大きなマッピングテーブルやデータバッファを必要とする可能性のある FTL にとっては大きな制約となる。FTL、特にページマップ方式のものは、マッピングテーブルのためにかなりの RAM を必要とする場合がある <sup>16</sup>。ガベージコレクションやウェアレベリングも、データバッファリングのために RAM を必要とすることがある。MicroPython ランタイム自体も 264KB の SRAM の一部を消費する <sup>5</sup>。Kioxia 製 NAND は 2176 バイトのページサイズを持つため <sup>3</sup>、単一ページバッファでさえも無視できないサイズとなる。このため、RAM の最適化が最優先事項となる。これは、メモリ効率のための C レベルでの実装と、FTL データ構造の慎重な設計の必要性を補強する。マッピングテーブルの一部分をオンデマンドでロードするなどの戦略が必要になるかもしれない。

### **C. Kioxia TC58NVG0S3HTA00 NAND フラッシュ：詳細技術プロファイル**

JISC-SSD に搭載されている NAND フラッシュは、Kioxia 製の TC58NVG0S3HTA00 である <sup>19</sup>。これは 1Gbit (128MByte) の容量を持つ RAW NAND E2PROM であり、ホスト側での FTL 管理と ECC 処理を必要とする <sup>3</sup>。

1. パラレルインターフェース信号とコマンドセット: \
   この NAND フラッシュは、ALE (Address Latch Enable)、CLE (Command Latch Enable)、WE (Write Enable)、RE (Read Enable)、CE (Chip Enable)、I/O0-7 (8 ビットデータバス)、WP (Write Protect)、RY/BY (Ready/Busy) といった標準的なパラレル NAND インターフェース信号を使用する 3。これらの信号の正確な機能とタイミングを理解することは、PIO またはビットバンギングによるドライバを設計する上で基本となる。NAND フラッシュは、I/O バスを介してコマンド、アドレス、データを送信し、ALE、CLE、WE、RE、CE などの制御信号によって調整されることで制御される 3。RY/BY 信号はフロー制御に不可欠であり、デバイスが内部操作でビジー状態であることを示す。不正確な信号操作は、操作の失敗やデバイスの誤動作につながる。したがって、低レベルドライバ（PIO または C 言語ビットバンギング）は、これらの信号によって定義されるコマンドシーケンスとタイミング要件を細心の注意を払って実装する必要がある。 \
   主要なコマンドオペコードには、Read ID (90h)、Read Page (00h, 30h)、Auto Page Program (80h, 10h)、Auto Block Erase (60h, D0h)、Status Read (70h)、Reset (FFh) などがある 3。
2. メモリ構成：ページ、ブロック、スペア領域構造: \
   TC58NVG0S3HTA00 のページサイズは合計 2176 バイトで、その内訳は 2048 バイトのデータ領域と 128 バイトのスペア領域である 3。1 ブロックは 64 ページで構成され、ブロックサイズは (128K + 8K) バイトとなる 3。スペア領域は、ECC データ、不良ブロックマーカー、その他の FTL メタデータ（LBA、消耗度カウント、バージョン情報など）の格納に使用される 3。 \
   2048 バイトのデータページあたり 128 バイトのスペア領域は、堅牢な FTL および ECC 実装にとって十分であり、重要である。Kioxia チップは 512 バイトのデータあたり 8 ビットの ECC を必要とする 3。2048 バイトのページの場合、これは 4 つの ECC セグメントを意味する。512 バイトに対して 8 ビット訂正を行う BCH 符号は、通常、セグメントあたり約 13〜14 バイトの ECC データを必要とする（一般的な ECC 知識および 39 から派生。T=8 の場合、ceil(BCH*T * 13/8)または ceil(BCH*T * 14/8)バイト）。したがって、4 セグメント \* 約 14 バイト/セグメント = 約 56 バイトが ECC に必要となる。これにより、スペア領域には 128 - 約 56 = 約 72 バイトが残る。この残りのスペースは、不良ブロックマーカー（通常 1〜2 バイト）およびその他の FTL メタデータには十分である。したがって、スペア領域のサイズは必要な ECC および典型的な FTL メタデータに対して十分であり、スペア領域内のスペース競合が設計上の大きな懸念事項とはなりにくい。
3. ECC 要件（ホスト側、512 バイトあたり 8 ビット）: \
   製造元は、メインページデータの 512 バイトセクターごとに 8 ビットの ECC 処理をホストコントローラ（この場合は RP2040）側で行うことを要求している 3。これは交渉の余地のない重要な要件であり、FTL は 8 ビット訂正能力を持つ ECC アルゴリズム（BCH など）を組み込まなければならない。
4. 不良ブロックの識別と製造元マーキング: \
   不良ブロックは、そのブロック内のいずれかのページの特定カラムのデータが 00h である場合に識別される 3。通常、このマーカーはブロックの最初のページまたは最後のページのスペア領域でチェックされる。出荷時にはブロック 0 が有効ブロックであることが保証されている 3。システムはこれらの不良ブロックを管理し、消去操作を避ける責任がある。FTL の初期化プロセスには、この 00h の慣例に基づいて工場でマークされた不良ブロックのスキャンが含まれなければならない。ブロック 0 が良好であることは、必要に応じて初期 FTL メタデータを格納するための安全な開始点を提供する。

**表 2：Kioxia TC58NVG0S3HTA00 NAND フラッシュ - 主要特性**

<table>
  <tr>
   <td><strong>特性</strong>
   </td>
   <td><strong>仕様</strong>
   </td>
   <td><strong>出典</strong>
   </td>
  </tr>
  <tr>
   <td>総容量
   </td>
   <td>1 Gbit (128 MByte)
   </td>
   <td><sup>3</sup>
   </td>
  </tr>
  <tr>
   <td>ページサイズ（合計）
   </td>
   <td>2176 バイト
   </td>
   <td><sup>3</sup>
   </td>
  </tr>
  <tr>
   <td>ページデータ領域
   </td>
   <td>2048 バイト
   </td>
   <td><sup>3</sup>
   </td>
  </tr>
  <tr>
   <td>ページスペア領域
   </td>
   <td>128 バイト
   </td>
   <td><sup>3</sup>
   </td>
  </tr>
  <tr>
   <td>ブロックあたりページ数
   </td>
   <td>64
   </td>
   <td><sup>3</sup>
   </td>
  </tr>
  <tr>
   <td>ブロックサイズ
   </td>
   <td>139,264 バイト (128 KiB データ + 8 KiB スペア)
   </td>
   <td><sup>3</sup>
   </td>
  </tr>
  <tr>
   <td>ブロック数
   </td>
   <td>1024 (最小1004有効)
   </td>
   <td><sup>3</sup>
   </td>
  </tr>
  <tr>
   <td>ECC要件
   </td>
   <td>ホスト側、512データバイトあたり8ビット
   </td>
   <td><sup>3</sup>
   </td>
  </tr>
  <tr>
   <td>不良ブロックマーカー
   </td>
   <td>ブロック内任意ページの列データが00h（通常スペア領域で確認）
   </td>
   <td><sup>3</sup>
   </td>
  </tr>
  <tr>
   <td>保証される良好ブロック
   </td>
   <td>ブロック0
   </td>
   <td><sup>3</sup>
   </td>
  </tr>
  <tr>
   <td>主要コマンドオペコード
   </td>
   <td>Read ID (90h), Read Page (00h, 30h), Page Program (80h, 10h), Block Erase (60h, D0h), Status Read (70h), Reset (FFh)
   </td>
   <td><sup>3</sup>
   </td>
  </tr>
</table>

この表は、対象となる NAND フラッシュの全ての重要なパラメータを統合しており、FTL データ構造、ECC 実装、低レベルドライバロジックに関する全ての決定の基礎となる。

## **IV. RP2040 における Kioxia NAND フラッシュとのインターフェース**

JISC-SSD 上で Kioxia NAND フラッシュを制御するためには、RP2040 の GPIO ピンと NAND 信号間の物理的な接続を理解し、適切な低レベル制御戦略を選択する必要がある。

### **A. JISC-SSD 上のハードウェアピン配置と信号接続（RawNAND_Pico_pinout.xlsx の分析）**

NAND フラッシュ信号（ALE, CLE, WE, RE, CE, I/O0-7, WP, R/B）に対応する正確な RP2040 GPIO ピンのマッピングは、rawnand_test プロジェクトに同梱されている RawNAND_Pico_pinout.xlsx ファイルに記載されていると予想される <sup>19</sup>。本報告書の執筆時点では、この Excel ファイルの内容は提供された資料からは直接アクセスできなかった。したがって、開発者はこのファイルを参照し、ピンマッピングを特定する必要がある。これが、NAND ドライバコードを記述するための絶対的な基礎情報となる。

rawnand_test プロジェクトとその関連ピン配置ファイルは、JISC-SSD のハードウェアインターフェースを理解する上で非常に貴重な出発点であり、リバースエンジニアリングの労力を大幅に削減できる可能性がある。JISC-SSD は特定のボードであり <sup>19</sup>、rawnand_test プロジェクトはこのボードとその Kioxia NAND 専用に作成されている <sup>19</sup>。この既存の作業をピンマッピングと基本的な通信シーケンスの確立に活用することは、開発を加速させるために強く推奨される。

**表 3：JISC-SSD における RP2040 GPIO と Kioxia NAND 信号のマッピング**

<table>
  <tr>
   <td><strong>NAND信号</strong>
   </td>
   <td><strong>RP2040 GPIOピン</strong>
   </td>
  </tr>
  <tr>
   <td>ALE
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>CLE
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>WE
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>RE
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>CE
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>I/O0
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>I/O1
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>I/O2
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>I/O3
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>I/O4
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>I/O5
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>I/O6
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>I/O7
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>WP
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
  <tr>
   <td>R/B
   </td>
   <td><em>RawNAND_Pico_pinout.xlsxより特定</em>
   </td>
  </tr>
</table>

_注意：上記の表の「RP2040 GPIO ピン」列は、開発者が RawNAND_Pico_pinout.xlsx ファイルを参照して具体的に埋める必要がある。_

### **B. 低レベル NAND 制御戦略**

NAND フラッシュとの通信を実現するには、主に直接 GPIO 操作（ビットバンギング）と RP2040 の PIO を利用する方法の 2 つが考えられる。

1. 直接 GPIO 操作：実現可能性と限界 \
   NAND 制御を C 言語コードから RP2040 の GPIO ピンを直接トグルすることで実装する（ビットバンギング）アプローチが考えられる。rawnand_test C++サンプルプロジェクト 25 は、おそらくこのアプローチを採用している（ソースコードが直接参照できないため推測）。このプロセスでは、ピンの方向設定、コマンド/アドレスバイトのビット単位またはバイト単位での書き込み、制御線（WE, RE, ALE, CLE）のパルス生成、R/B（Ready/Busy）ピンのポーリングなどが含まれる。これは実現可能であるものの、CPU 負荷が高く、特に MicroPython 環境下（C 拡張機能が MicroPython スケジューラによってある程度管理される）では、高速 NAND の正確なタイミング制御が困難になる可能性がある。 \
   rawnand_test がおそらく直接 GPIO 操作を使用している（初期ハードウェア立ち上げの一般的なアプローチ）一方で、この方法は NAND 操作中に RP2040 コアの 1 つを完全に消費し、システム全体のパフォーマンスと MicroPython の応答性に影響を与える可能性が高い。パラレル NAND はタイミング制御された GPIO 操作のシーケンスを必要とし 3、CPU コアによる直接ビットバンギングは、操作中はそのコアがこれらの信号管理に専念することを意味する。RP2040 は 2 つの M0+コアを持っており 17、1 つのコアが NAND I/O で占有されると、MicroPython や他のタスクに利用可能な処理能力が半減する。したがって、直接 GPIO ビットバンギングは概念実証としては有効だが、他のタスクを並行して実行することを目指すシステムにとっては最適とは言えず、PIO がより魅力的な解決策となる。
2. RP2040 プログラマブル I/O (PIO)によるパラレル NAND 制御 \
   PIO は、パラレル NAND インターフェースを処理するための優れた代替手段である 21。PIO ステートマシンは、CPU コアから独立して、制御信号（ALE, CLE, WE, RE, CE）の正確なシーケンスを生成し、8 ビットデータバス（I/O0-7）を管理するようにプログラムできる。 \* a. パラレルデータ転送のための PIO アーキテクチャと命令セット \
   PIO ブロックは、ステートマシン、命令メモリ、FIFO、シフトレジスタ（ISR/OSR）、スクラッチレジスタ（X,Y）などのコンポーネントで構成される 21。NAND 制御に関連する主要な PIO 命令には、データ/コマンド/アドレス送信用の out()、データ/ステータス読み出し用の in()、制御ピン設定用の set()、データ操作用の mov()、R/B 信号やタイミング待機用の wait()、ループ/条件分岐用の jmp()、CPU へのシグナリング用の irq()などがある 21。サイドセット機能や遅延機能も重要である。 \
   PIO の FIFO と DMA 機能は、ページ読み出し/書き込み操作で高いスループットを達成し、PIO プログラムが開始された後の CPU の関与を最小限に抑える鍵となる。NAND ページは大きい（2176 バイト 3）ため、このデータを CPU の介入によってバイトごとに PIO に転送するのは遅い。PIO ステートマシンは TX および RX FIFO を持ち 21、これらの FIFO はシステム DMA にリンクできる 21。したがって、効率的なページ転送のためには、CPU は DMA を使用して PIO FIFO を充填/空にし、PIO ステートマシンが各バイトに対してさらなる CPU 対話なしに高速でデータをクロックイン/アウトできるようにすべきである。 \
   **表 4：パラレル NAND 制御に関連する RP2040 PIO 命令**

<table>
  <tr>
   <td>
<strong>命令</strong>
   </td>
   <td><strong>説明</strong>
   </td>
   <td><strong>NANDでの使用例</strong>
   </td>
  </tr>
  <tr>
   <td>out(pins, count) など
   </td>
   <td>OSRから指定されたpinsまたは他の宛先にcountビットをシフトする。
   </td>
   <td>コマンドバイト、アドレスバイト、データバイトをNAND I/Oバスに送信する。
   </td>
  </tr>
  <tr>
   <td>in(pins, count) など
   </td>
   <td>指定されたpinsまたは他のソースからISRにcountビットをシフトする。
   </td>
   <td>データバイトまたはステータスバイトをNAND I/Oバスから読み取る。
   </td>
  </tr>
  <tr>
   <td>set(pins, value) など
   </td>
   <td>指定されたpinsまたはレジスタをvalueに設定する。
   </td>
   <td>CE, ALE, CLE, WE, RE, WPなどの制御信号をアサート/デアサートする。
   </td>
  </tr>
  <tr>
   <td>wait(polarity, src, index)
   </td>
   <td>indexのsrc (GPIO, PIN, IRQ) がpolarityに一致するまで実行を一時停止する。
   </td>
   <td>R/B信号の準備完了を待機する。特定のタイミング遅延を待機する。
   </td>
  </tr>
  <tr>
   <td>mov(dest, src)
   </td>
   <td>srcからdestにデータを移動する。
   </td>
   <td>PIO内部でのデータ操作、outのためのデータ準備、inからのデータ処理。
   </td>
  </tr>
  <tr>
   <td>jmp(cond, label)
   </td>
   <td>condが満たされた場合にlabelにジャンプする。
   </td>
   <td>バイト/ページ転送のループ、ステータスに基づく条件付きロジック。
   </td>
  </tr>
  <tr>
   <td>nop()
   </td>
   <td>無操作。タイミング調整に使用。
   </td>
   <td>NANDプロトコルで要求されるセットアップ/ホールド時間を微調整する。
   </td>
  </tr>
  <tr>
   <td>修飾子: .side(value)
   </td>
   <td>メイン命令と同時にサイドセットピンにvalueを出力する。
   </td>
   <td>データ転送と同時にWE/REストローブなどの信号を効率的に制御する。
   </td>
  </tr>
  <tr>
   <td>修飾子: [delay]
   </td>
   <td>命令実行後にdelayサイクル追加する。
   </td>
   <td>制御信号とデータのセットアップ/ホールド時間を確保する。
   </td>
  </tr>
</table>

    *出典: [21, 23, 29, 30]* \

\

- b. **NAND 操作のための概念的な PIO プログラム構造** \
  基本的な NAND アクション（コマンド送信、アドレス送信、データバイト書き込み、データバイト読み出し、準備完了待機）のためのモジュール化された PIO 設計は、保守性とデバッグの容易性を向上させる。NAND 操作はこれらの基本的なアクションのシーケンスで構成され [3]、PIO プログラムはラベルとジャンプを使用して関数のように構造化できる [29]。全ての NAND 操作のためのモノリシックな PIO プログラムは複雑で管理が困難になるため、共通の低レベルタスクのための再利用可能な「サブルーチン」を持つ PIO コードを設計することで、より高レベルな NAND コマンドシーケンス（例：ページプログラム = send_cmd_80h + send_addrs + write_page_data_pio + send_cmd_10h + wait_ready_pio）の開発が簡素化される。 \
  PIO のサイドセット機能は、データバスへのデータ配置と同時に WE/RE ストローブを生成するのに特に強力であり、タイミング効率を向上させることができる。NAND 操作では、転送されるバイト/ワードごとに WE/RE をパルスする必要があり [3]、PIO 命令は`side()`修飾子を持つことで同じサイクルで追加のピンを制御できる [29, 30]。WE/RE がサイドセットピンとして設定されていれば、データを送信するための`out()`命令がサイドセットを介して同時に WE ストローブをトリガーできる。したがって、WE/RE ストローブにサイドセットを利用することで、PIO プログラムをよりコンパクトにし、データと制御信号間の正確なタイミングアライメントを確保できる。 \
  個別の PIO プログラムまたは PIO プログラム内の関数で、以下の処理をどのように行うかを概説する： \
  - コマンドバイトの送信（CLE を設定、I/O にバイトを出力、WE をパルス） \
  - アドレスバイトの送信（ALE を設定、I/O にバイトを出力、WE をパルス） \
  - データページの書き込み（ループ：I/O にバイトを出力、WE をパルス） \
  - データページの読み出し（ループ：RE をパルス、I/O からバイトを取得） \
  - R/B 信号の待機 \
    1 つまたは複数のステートマシンを使用することを検討する。例えば、制御信号とデータ用に 1 つ、あるいは複雑な場合は読み出しパスと書き込みパス用に別々のステートマシンを使用する [28]。 \

## **V. MicroPython における FTL 実装戦略**

MicroPython をプラットフォームとして FTL を実装するには、その言語特性と RP2040 上の実行環境を考慮した戦略が必要となる。

### **A. RP2040 上の MicroPython：FTL 開発における強みと制約**

MicroPython は、迅速な開発、使いやすさ、Python エコシステムの活用、対話型テストのための REPL (Read-Evaluate-Print Loop) といった強みを持つ <sup>4</sup>。一方で、低レベルで高頻度な操作に対するインタプリタの性能オーバーヘッド、C 言語と比較した場合の RAM 使用量の増加、ガベージコレクタによる一時停止といった制約も存在する <sup>4</sup>。RP2040 向けの MicroPython には、PIO アクセス用の rp2 モジュールや GPIO アクセス用の machine モジュールが提供されている <sup>29</sup>。

MicroPython は、FTL の高レベルなロジック、ポリシー決定（例：ガベージコレクションのトリガー時期、ウェアレベリングアルゴリズム）、ユーザー向け API には優れているが、直接的でサイクルクリティカルな NAND 信号操作や集中的な ECC 計算には適していない。MicroPython は迅速なプロトタイピングと C 言語よりも複雑なロジックの容易な表現を提供し <sup>4</sup>、FTL は高レベルの意思決定（例：ウェアレベリングのためのブロック選択、GC ヒューリスティック）を含む。しかし、直接的な NAND 制御は正確で高速な信号トグルを必要とし <sup>3</sup>、ECC は計算集約的である。MicroPython のインタプリタオーバーヘッドは、これらの性能クリティカルなタスクには不向きである <sup>4</sup>。したがって、最適なのは階層的アプローチであり、MicroPython が FTL ポリシーを扱い、C モジュールが FTL 機構を管理する。

### **B. MicroPython における性能ボトルネックとメモリ管理**

FTL 操作（マッピングルックアップ、GC、ウェアレベリング決定など）が純粋な Python で記述された場合、頻繁に実行されるとファイルシステム性能の低下につながる可能性がある。MicroPython のヒープとガベージコレクタ <sup>5</sup>、そして FTL 用の大きなデータ構造（マッピングテーブル、ページバッファなど）は、メモリを圧迫し、頻繁な GC サイクルを引き起こし、さらに性能に影響を与える可能性がある。

FTL データ構造のための C モジュールにおける効率的なメモリ使用は、MicroPython のヒープを枯渇させたり、過度の GC アクティビティを引き起こしたりするのを避けるために最も重要である。RP2040 は合計 264KB の SRAM しか持たず <sup>17</sup>、MicroPython ランタイムとヒープはこの一部を使用する <sup>5</sup>。FTL マッピングテーブルとページバッファは大きくなる可能性があり（ページバッファあたり 2KB、マッピングテーブルは数十 KB になることも）、これらが MicroPython ヒープで管理されると、フラグメンテーションや頻繁で長い GC ポーズにつながる可能性がある。したがって、大きいか頻繁にアクセスされる FTL データ構造は C モジュール内で管理し、必要であればシステムヒープから malloc を使用するか、サイズが固定で既知であれば静的に割り当てるべきである。これにより、MicroPython ヒープへの圧力が最小限に抑えられる。

### **C. MicroPython の uos モジュールを活用したブロックデバイス抽象化**

MicroPython の uos モジュールは、ファイルシステムのマウントやブロックデバイスの操作を含む OS ライクなインターフェースを提供する <sup>32</sup>。実装された FTL（おそらく C オブジェクトとして）は、uos.mount()が使用できるブロックデバイスインターフェース（readblock、writeblock、ioctl）を公開することができる。これにより、標準的な MicroPython ファイルシステム（vfs.FAT など）を FTL の上に階層化することが可能になる。

FTL を MicroPython のブロックプロトコルに準拠したカスタムブロックデバイスクラスとして C 言語で実装することは、それを MicroPython エコシステムに統合する標準的な方法である。MicroPython の uos モジュールは、ブロックデバイスプロトコル（通常、readblocks(block_num, buf)、writeblocks(block_num, buf)、ioctl(op, arg)といったメソッドを含む）に準拠するオブジェクトのマウントをサポートする <sup>32</sup>。C ユーザーモジュールは、これらのメソッドを実装する新しい型を定義し、基礎となる FTL ロジックおよび NAND ドライバと対話することができる。したがって、FTL はこれらのブロックデバイスメソッドを実装するオブジェクトとして MicroPython に公開されるべきである。これにより、例えば uos.mount(my_ftl_device, "/nandfs")に続いて標準的なファイル操作が可能になる。

### **D. 性能クリティカルな FTL ロジックのための C ユーザーモジュールの必須の役割**

許容可能な性能を得るためには、コア FTL アルゴリズム（マッピング、GC、性能に敏感なウェアレベリングロジック）、ECC 計算、および PIO ベースの NAND ドライバを C ユーザーモジュールとして実装する必要があることを再度強調する <sup>4</sup>。MicroPython がこれらの C モジュール内の関数をどのように呼び出すかを説明する。

1. MicroPython からの PIO 制御 NAND ドライバのインターフェース: \
   C モジュールは PIO ステートマシンを初期化し管理する。そして、nand_read_page(lba, buffer)、nand_write_page(lba, buffer)、nand_erase_block(lba)のような関数を MicroPython に公開する。これらの関数は内部で PIO を使用して NAND と通信し、他の C ベースの FTL コンポーネントと対話する。 \
   C モジュールはブリッジとして機能し、PIO の複雑さを MicroPython レベルから抽象化する。MicroPython は単純な C 関数を呼び出し、それが複雑な PIO 操作と DMA 転送を調整する。PIO プログラミングはアセンブリのロード、ステートマシンの設定、FIFO/DMA の管理を含み 21、この生の複雑さを MicroPython スクリプトに公開するのは非効率的で扱いにくい。C 関数はこれらの詳細をカプセル化し、クリーンな API（例：read_physical_page(ppa, buffer)）を提供できる。したがって、C モジュールは NAND 操作のための高レベル API を MicroPython に提供し、PIO の複雑な詳細を隠蔽すべきである。
2. C 言語での ECC およびコア FTL アルゴリズムの実装: \
   ECC（BCH エンコーディング/デコーディング）が C 関数としてどのように実装されるかを議論する。同様に、マッピングテーブルの更新、不良ブロックテーブル管理、そして潜在的にはガベージコレクションやウェアレベリングの一部のようなコア FTL ロジックも、速度とメモリ効率のために C 言語で実装される。 \
   どの FTL アルゴリズムを C で実装し、どれを MicroPython で実装するかの選択にはトレードオフが伴う。C は性能を提供し、MicroPython はポリシーの容易な開発と変更を提供する。ECC と低レベルのマップ更新は性能クリティカルでデータ集約的であり、C に適している。ガベージコレクションにおける犠牲ブロックの選択のための特定のヒューリスティックやウェアレベリング戦略のような、より高レベルの FTL ポリシーは、柔軟性のために MicroPython での実装または C モジュール API を介した MicroPython からの設定に適しているかもしれない。したがって、ハイブリッドアプローチが最善である可能性が高い。つまり、基本的で高頻度の FTL 操作は C で、ポリシーレベルの決定は潜在的に MicroPython で、または MicroPython から設定可能にする。

## **VI. FTL ソフトウェアソリューションの調査と分析**

JISC-SSD 上で FTL を実装するために利用可能なソフトウェアソリューションやアプローチを評価する。

### **A. Dhara FTL：アーキテクチャ、HAL (nand.h) 要件、および統合パス**

Dhara は、リソースが限られたシステムおよび RAW NAND フラッシュ向けに設計された小型 FTL であり、ウェアレベリングとデータ整合性を提供する <sup>7</sup>。そのアーキテクチャはマップベースである。特に重要なのは、nand.h で定義されたハードウェア抽象化レイヤ（HAL）である <sup>8</sup>。ユーザーは、dhara_nand_is_bad、dhara_nand_mark_bad、dhara_nand_erase、dhara_nand_prog（ECC 処理を含む必要がある）、dhara_nand_is_free、dhara_nand_read（ECC 処理とエラー報告を含む必要がある）、および dhara_nand_copy といった関数を提供しなければならない <sup>8</sup>。この HAL は、セクション IV.B.2 で開発された PIO ドライバを使用して C 言語で実装されることになる。

Dhara の HAL 設計は、ECC 処理をプラットフォーム固有の nand.h 実装に明示的に委任している。これは、dhara_nand_prog 関数が生データを受け取り、ECC を計算し、両方をフラッシュに書き込む必要があることを意味する。dhara_nand_read はデータと ECC を読み取り、訂正を実行し、訂正されたデータまたはエラーを返さなければならない。Dhara の nand.h <sup>8</sup> は prog と read のシグネチャを指定しており、<sup>8</sup>のコメントには「prog: ECC とチェックサムを含む NAND ページをプログラムする」および「read: （部分的な場合もある）NAND ページを読み取り、必要に応じて ECC を試みる...訂正不可能なエラーは検出されなければならない」と記載されている。したがって、JISC-SSD 用の Dhara HAL を実装する C モジュールは、BCH ECC ロジックをその prog および read 関数内に直接統合しなければならない。Dhara 自体は ECC を実行せず、HAL がそれを行うことに依存している。

Dhara を統合するには、NAND アクセス用の RP2040 PIO ドライバを使用し、選択された BCH ECC ライブラリを組み込んだ新しい C ベースの HAL を作成することが含まれる。Dhara コアロジックは、この HAL の上で動作することができる。Dhara は FTL ロジック（ウェアレベリング、マッピング、GC）を提供し <sup>8</sup>、ハードウェア固有の HAL（nand.h 関数）を必要とする <sup>8</sup>。PIO ドライバ（セクション IV.B.2）は物理ページを erase、program、read する手段を提供し、ECC ライブラリ（セクション VII）は encode および decode 関数を提供する。したがって、Dhara を使用するための主な開発作業は、PIO ドライバ、ECC ライブラリ、および Kioxia NAND の特定の特性（ページサイズ、不良ブロックマーキング）を接着するこの nand.h HAL 実装を作成することになる。

### **B. LittleFS：RAW NAND への適用性、ECC に関する考慮事項、および消去ブロックサイズの影響**

LittleFS は、主に NOR フラッシュや、eMMC、SD カードのような消去単位が小さく ECC/管理機能が内蔵されたデバイス向けに設計されている <sup>9</sup>。RAW NAND に対する懸念事項としては、ユーザーが ECC を提供しなければならない点、NAND の大きな消去単位（Kioxia の場合は 128KB）は各ファイルが少なくとも 1 ブロック全体を使用することを意味し、多数の小さなファイルを使用する場合はスペースを浪費する可能性がある点が挙げられる <sup>9</sup>。一部のユーザーはハードウェア ECC を備えた SPI NAND 上で LittleFS が成功したと報告しているが <sup>9</sup>、Kioxia TC58NVG0S3HTA00 はホスト ECC を必要とする。

LittleFS は電力損失耐性とウェアレベリングを提供するが、Kioxia RAW NAND への直接使用は、ECC と大きな消去ブロックサイズを処理するための中間 FTL または大幅な適応なしには問題がある。LittleFS は、基礎となるブロックデバイスが ECC を処理するか、エラーが書き込みエラーとして現れることを期待している <sup>9</sup>。Kioxia NAND は ECC 訂正が必要な読み取りエラーを持つ <sup>1</sup>。LittleFS の設計はより小さな消去単位を想定しており、小さなファイルストレージに対して 128KB の消去単位 <sup>3</sup> は非常に非効率的である <sup>9</sup>。したがって、LittleFS 自体は、この RAW NAND に対する完全な FTL ソリューションではない。ECC と潜在的に小さな仮想ブロックサイズを提供する下位レベルの FTL の上に置かれるか、LittleFS 自体が大幅な変更を必要とするだろう。

### **C. カスタム FTL に関する考慮事項：複雑さと制御のトレードオフ**

カスタム FTL をゼロから開発することは、アルゴリズムの完全な制御、特定のワークロードへの最適化、必須機能のみを実装する場合の潜在的なフットプリントの縮小といった利点がある。しかし、FTL の全ての側面（ウェアレベリング、GC、不良ブロック管理、ECC 統合、電力損失安全性）の正しさと堅牢性を保証するための開発努力は膨大であり、複雑性が高いという欠点もある <sup>1</sup>。

カスタム FTL をゼロから開発することは非常に高度な作業であり、特に堅牢性とウェアレベリング/ガベージコレクションの相互作用の正確性を保証することは困難である。FTL は複数の複雑で相互作用するアルゴリズムを含み <sup>1</sup>、データ整合性、電力障害安全性、最適なウェアレベリングを保証するには慎重な設計と広範なテストが必要である。FTL のバグはデータ損失やデバイスの早期故障につながる可能性がある。したがって、最大の制御を提供する一方で、カスタム FTL は高リスク、高努力の選択肢である。HAL を実装できるのであれば、Dhara のような既存の十分にテストされた FTL コアを活用する方が一般的に好ましい。

**表 5：JISC-SSD 向け FTL ソフトウェアアプローチの比較**

<table>
  <tr>
   <td><strong>特徴/側面</strong>
   </td>
   <td><strong>DharaベースFTL</strong>
   </td>
   <td><strong>LittleFS (RAW NAND上)</strong>
   </td>
   <td><strong>カスタムFTL</strong>
   </td>
  </tr>
  <tr>
   <td>ウェアレベリング
   </td>
   <td>コアFTLが提供
   </td>
   <td>下位にFTLが必要
   </td>
   <td>カスタム実装
   </td>
  </tr>
  <tr>
   <td>不良ブロック管理
   </td>
   <td>コアFTLが提供
   </td>
   <td>下位にFTLが必要
   </td>
   <td>カスタム実装
   </td>
  </tr>
  <tr>
   <td>ガベージコレクション
   </td>
   <td>コアFTLが提供
   </td>
   <td>下位にFTLが必要
   </td>
   <td>カスタム実装
   </td>
  </tr>
  <tr>
   <td>ECC処理
   </td>
   <td>HAL実装が必要
   </td>
   <td>ユーザー層または下位FTLが必要
   </td>
   <td>カスタム実装
   </td>
  </tr>
  <tr>
   <td>Kioxia RAW NANDへの適合性
   </td>
   <td>HALがあれば良好
   </td>
   <td>直接は不向き、FTLが必要
   </td>
   <td>高い開発努力
   </td>
  </tr>
  <tr>
   <td>MicroPython統合の労力
   </td>
   <td>CでのHAL、CでのFTLコア、MPバインディング
   </td>
   <td>LittleFS MPポートは存在するが、ECC/ブロック層が必要
   </td>
   <td>完全なCモジュール + MPバインディング
   </td>
  </tr>
  <tr>
   <td>RAM使用量
   </td>
   <td>中程度（マップキャッシュに依存）
   </td>
   <td>大ブロックでのメタデータで潜在的に高い
   </td>
   <td>可変
   </td>
  </tr>
  <tr>
   <td>開発の複雑さ
   </td>
   <td>中程度：HAL + ECC
   </td>
   <td>RAW NANDへの適応は高
   </td>
   <td>非常に高い
   </td>
  </tr>
  <tr>
   <td>成熟度/テスト
   </td>
   <td>コアはテスト済み
   </td>
   <td>ファイルシステムはテスト済みだがRAW NAND FTLとしては未
   </td>
   <td>新規、未テスト
   </td>
  </tr>
</table>

_出典: <sup>7</sup>_

この比較表は、プロジェクトの優先順位（開発時間、制御、リソース使用量など）に基づいて最も実行可能な FTL 実装戦略を選択するのに役立つ。

## **VII. ホスト側エラー訂正（ECC）の実装**

Kioxia TC58NVG0S3HTA00 NAND フラッシュはホスト側での ECC 処理を必須としているため、FTL 実装において ECC は中心的な役割を果たす。

### **A. Kioxia TC58NVG0S3HTA00 の ECC 指令への対応**

Kioxia のデータシートは、512 バイトのデータごとに 8 ビットの ECC 処理を要求していることを再度強調する 3。これは、2048 バイトのデータページごとに、4 つの独立した ECC 計算/チェックが必要であることを意味する。

ECC 実装は、2048 バイトページ内の 512 バイトレベルで細分化されなければならない。データシートは「512 バイトごとに 8 ビット ECC」を指定しており 3、ページデータ領域は 2048 バイトであるため 3、2048/512=4 となる。したがって、ECC C モジュールは 512 バイトのデータチャンクを受け取り、それに対する ECC バイトを生成して付加できなければならない。読み取り時には、512 バイトのチャンクとその ECC バイトを受け取り、訂正を実行し、ステータスを報告する必要がある。このプロセスはページごとに 4 回繰り返される。

### **B. NAND フラッシュ用 BCH 符号の概要**

BCH（Bose-Chaudhuri-Hocquenghem）符号は、NAND フラッシュで一般的に使用される強力な ECC の一種であり、複数のランダムビットエラーを訂正できる 36。その数学的基礎はガロア体上の多項式であるが、ここでは詳細な説明は省略する。パラメータとしては、m（ガロア体のサイズ）や t（ビット単位でのエラー訂正能力）などがある。

BCH 符号は、Kioxia NAND の 8 ビットエラー訂正要件に適している。Kioxia は 8 ビットのエラー訂正を要求しており 3、BCH 符号はその強力なマルチビットエラー訂正能力で知られ、NAND コントローラで広く使用されている 36。したがって、BCH は ECC アルゴリズムとして適切な選択である。512 バイトのデータブロックに対して、特定の BCH パラメータ（多項式、m、t=8）を選択する必要がある。

### **C. 軽量 C ベース BCH ライブラリの評価（Dhara ecc/、その他ソースなど）**

RP2040 にはハードウェア NAND ECC コントローラがないため、ソフトウェア BCH ライブラリが必要となる。Dhara のソースには ECC 実装が含まれていることが言及されている <sup>8</sup>。その他、組み込み可能な軽量 C ベース BCH ライブラリ（例：Linux カーネルの BCH ライブラリ <sup>37</sup>、bchlib をラップしている可能性のある Python の bchlib <sup>38</sup>）を検索する。512 バイト（4096 ビット）のデータブロックに対して t=8 の訂正能力、コードサイズ、メモリフットプリント、統合の容易さに基づいて評価する。

Linux カーネルの BCH ライブラリ <sup>37</sup> は包括的であるものの、その全体を使用する場合、マイクロコントローラには重すぎる可能性がある。しかし、そのコアアルゴリズムを適応させるか、より専門的な組み込みライブラリが好ましいかもしれない。Dhara にバンドルされている ECC（t=8 に適した BCH を含む場合）は強力な候補となるだろう。RP2040 はリソースに制約があり <sup>6</sup>、完全なカーネルライブラリは不要な依存関係や機能を持つ可能性があり、コードサイズを増大させる。Dhara は MCU 向けに設計されているため、その ECC コンポーネントはそのような環境に最適化されている可能性が高い <sup>8</sup>。Kioxia チップは 512 バイトのデータブロックあたり 8 ビットの訂正（t=8）を必要とする。BCH パラメータ（生成多項式、体サイズ m）はこれをサポートしなければならない。n=データビット+ECC ビット、k=データビット、2m−1≥n となる m について。512 データバイト（4096 ビット）および t=8 の場合、ECC ビットは約 m×t である。m=13（NAND で一般的な GF(2m)の体サイズ）の場合、ECC ビット = 13×8=104 ビット = 13 バイトとなる。これは 512 バイトセグメントあたりのスペア領域に収まる。したがって、BCH ライブラリの検索は、設定可能な t とブロックサイズを持つ組み込み用途向けに設計されたものを優先すべきである。Dhara の ECC コードが最初に評価されるべきであり、m=13、t=8、データブロック=512 バイトのパラメータは標準的と思われる。

### **D. C モジュール内への BCH エンコーディング/デコーディングの統合**

選択された BCH ライブラリ関数（例：bch_encode(data, ecc_out)、bch_decode(data, ecc_in)）が、C NAND ドライバ（Dhara を使用する場合は HAL 関数内、または PIO ドライバのページ読み書き関数内）からどのように呼び出されるかを記述する。MicroPython からのデータは、ECC 処理のためにこの C レイヤを通過することを説明する。

ECC プロセスは、物理的なページの読み書きと密接に結合されなければならない。ECC はフラッシュへの書き込み前にデータに対して計算され 36、フラッシュからの読み取り直後にデータのチェックと訂正に使用される 36。したがって、PIO を介して物理ページアクセスを実行する C 関数は、512 バイトセクタをプログラムする直前に BCH エンコード関数を呼び出し、512 バイトセクタとその対応する ECC バイトをスペア領域から読み取った直後に BCH デコード関数を呼び出さなければならない。

## **VIII. 開発、テスト、および検証アプローチ**

FTL の実装は複雑なため、段階的な開発と徹底的なテストが不可欠である。

### **A. 初期低レベル NAND 通信（rawnand_test の概念に基づく構築）**

まず、rawnand_test プロジェクトの機能（Read ID、Read Status、FTL ロジックなしの基本的なページ読み書き/消去）を再現するための基本的な C 関数（最初から PIO を使用する可能性が高い）から始めることを提案する 19。これにより、FTL の複雑さを追加する前に、ハードウェアインターフェースと PIO 制御が検証される。

このプロジェクト全体は複雑（NAND + PIO + ECC + FTL + MicroPython）であり、全てを一度に構築しようとするとデバッグが非常に困難になる。rawnand_test プロジェクトは、JISC-SSD 上の基本的な NAND コマンドに対する既知の（おそらく）良好な出発点を提供する 25。したがって、最初の開発マイルストーンは、選択された低レベルドライバ（C 言語での PIO）を使用して基本的なコマンド（Read ID、Status Read）を確実に送信し、RAW ページを読み書きし、Kioxia データシート 3 と照合して検証することであるべきだ。これにより、物理層が機能していることが確認される。

### **B. FTL モジュールの段階的開発と単体テスト**

FTL コンポーネント（ECC、マッピング、不良ブロック管理、ウェアレベリング、GC）を段階的に開発することを記述する。各コンポーネントは、実際の PIO ドライバと統合する前に、C 言語でモック NAND インターフェースを使用して単体テストされるべきである。例えば、既知のデータパターンと注入されたエラーで ECC エンコーディング/デコーディングをテストする。シミュレートされた読み書きでマッピングロジックをテストする。

FTL コンポーネント、特に ECC とマッピングロジックを分離して単体テストすることで、システムレベルの統合前に多くのバグを捕捉できる。FTL アルゴリズムはステートフルであり、微妙なバグを持つ可能性がある。実際のフラッシュでのテストは遅く、特定のエラー条件を再現するのが難しい。NAND インターフェースをモック化することで、FTL ロジックの制御されたテスト（例：不良ブロックのシミュレーション、書き込み失敗、特定の摩耗パターン）が可能になる。したがって、各 FTL モジュールに対して C 単体テストを作成する。ECC については、様々なエラーパターンでテストする。マッピングについては、異なるシナリオ下でのアドレストランザクションをテストする。GC については、犠牲ブロックの選択とデータ移行をテストする。

### **C. JISC-SSD プラットフォームでのシステムレベル検証**

モジュールが単体テストされたら、それらを完全な FTL システムに統合する。ファイルシステム（例：uos.mount 経由の FAT）を使用して、ファイルの作成、削除、変更、および電源サイクルテストを実行し、データ整合性と電力損失回復を確認する。長期間のテスト実行を通じて、ウェアレベリングと不良ブロック処理を監視する。

電力サイクルテストは、FTL の堅牢性、特にデータ整合性とメタデータの一貫性を検証するために不可欠である。予期せぬ電力損失は組み込みシステムにおける一般的な故障モードであり 1、Dhara のような FTL はアトミックな更新とロールバック機能を目指している 8。したがって、システムレベルのテストには、様々なファイル操作中の多数のランダムな電源オフテストが含まれ、FTL がデータ損失なしに一貫した状態に回復できることを保証する必要がある。

## **IX. 包括的推奨事項と戦略的展望**

これまでの分析を踏まえ、JISC-SSD における MicroPython を用いた FTL 実装のための具体的な推奨事項と戦略的展望を提示する。

### **A. 推奨される FTL アーキテクチャと実装パス**

分析に基づき、具体的な FTL アーキテクチャを推奨する。RAW NAND およびリソース制約のある MCU への適合性から、Dhara ベースの FTL が有力である。実装パスは以下の通りとなる：

1. rawnand_test のピン配置情報を利用し、RP2040 上で Kioxia NAND 用の C ベース PIO ドライバを開発する。
2. C ベースの BCH ECC ライブラリ（t=8、512 バイトブロック対応）を選択または適応させる。
3. PIO ドライバと ECC ライブラリを統合し、Dhara の nand.h HAL を C 言語で実装する。
4. Dhara コアと新しい HAL を MicroPython C ユーザーモジュールとしてコンパイルする。
5. この C モジュールから MicroPython にブロックデバイスインターフェースを公開する。
6. このブロックデバイス上に標準ファイルシステム（例：FAT）をマウントする。

この推奨パスは、既存の堅牢な FTL ロジック（Dhara）を活用しつつ、特定のハードウェア（RP2040 PIO、Kioxia NAND、ECC）に必要なカスタム開発とのバランスを取るものである。Dhara はこの文脈のために設計されており <sup>8</sup>、PIO は RP2040 上で NAND を駆動する最良の方法である（考察 IV.B.2）。ホスト ECC は必須であり（考察 II.C）、性能のためには C モジュールが必要である（考察 V.D）。したがって、このアプローチは複雑な FTL アルゴリズムの再発明を最小限に抑え、ハードウェア固有のドライバと HAL に労力を集中させる。

### **B. 主要な技術的課題への対処と緩和戦略**

主要な課題として、PIO プログラミングの複雑さ、ECC 実装の正確性、FTL データ構造のための限られた RAM、MicroPython/C 連携の性能チューニング、FTL の堅牢性（特に電源断耐性）の確保が挙げられる。緩和戦略としては、モジュール化された PIO 設計、徹底的な ECC 単体テスト、慎重な FTL データ構造設計（マップキャッシュなど）、C モジュール性能のプロファイリング、広範な電源サイクルテストを提案する。

MicroPython、C モジュール、PIO、および外部 NAND フラッシュ間の相互作用のデバッグは複雑になる可能性がある。複数のソフトウェアおよびハードウェア層が関与し、PIO ステートマシンは CPU に対して非同期に実行される。MicroPython コンテキスト内での PIO 用デバッグツールは限定的である可能性がある（<sup>40</sup>は MP での PIO の「プッシュ・トゥ・プリント」デバッグに言及）。したがって、MicroPython からアクセス可能な C モジュール内の堅牢なロギングメカニズムが不可欠となる。また、開発中およびデバッグ中に PIO 信号と NAND 通信を観察するためにロジックアナライザを使用することも非常に貴重である。

### **C. 将来の機能強化と最適化の機会**

将来的な作業として、ガベージコレクション戦略の最適化、必要に応じたより高度なウェアレベリングアルゴリズムの実装、RAM に余裕があれば FTL レベルのキャッシュ追加、NAND/PIO セットアップが許せば Read-While-Write 機能の検討などが考えられる。

基本的な FTL が機能するようになったら、パフォーマンスプロファイリングによってさらなる最適化の取り組みを導くことができる。初期の FTL 実装は、正確性と安定性を優先すべきである。安定したら、プロファイリングによってボトルネック（例：GC、マップルックアップ、PIO 転送）を特定できる。したがって、将来の作業は、JISC-SSD 上の実際のパフォーマンスデータに基づいてターゲットを絞った最適化に焦点を当てることができる。

## **X. 結論**

本報告書では、RP2040 搭載 JISC-SSD ボード上で MicroPython を用いた Flash Translation Layer (FTL) の実装に関する技術的検討を行った。主要な結論と推奨事項は以下の通りである。

1. **実現可能性:** MicroPython 環境下での FTL 実装は、性能が重要な部分（低レベル NAND 制御、ECC、コア FTL アルゴリズム）を C 言語ユーザーモジュールとして実装することを前提とすれば技術的に実現可能である。純粋な MicroPython による実装は、性能とリソースの制約から実用的ではない。
2. **ハードウェアの活用:**
   - **RP2040 PIO:** Kioxia TC58NVG0S3HTA00 NAND フラッシュとのパラレルインターフェース制御には、RP2040 の PIO を活用することが強く推奨される。PIO は CPU 負荷を低減し、正確なタイミング制御を可能にする。
   - **Kioxia NAND:** この NAND フラッシュは RAW NAND であり、ページサイズ 2048+128 バイト、ブロックサイズ 128K+8K バイト、そしてホスト側での 512 データバイトあたり 8 ビットの ECC 処理を必須とする。これらの特性は FTL 設計に直接影響する。
3. **FTL ソフトウェア戦略:**
   - **Dhara FTL の利用:** 既存の組み込み向け FTL である Dhara は、RAW NAND 管理とウェアレベリング機能を提供するため、本プロジェクトのベースとして適している。主な開発作業は、RP2040 PIO ドライバと BCH ECC ライブラリを統合した Dhara HAL (nand.h) の C 言語による実装となる。
   - **ECC の実装:** 8 ビット訂正能力を持つ BCH 符号が適切であり、ソフトウェアライブラリとして C モジュールに統合する必要がある。ECC 処理はページ読み書き操作と密接に連携させる。
   - **カスタム FTL:** 完全なカスタム FTL の開発は、多大な労力と高度な専門知識を要するため、リスクが高い。
4. **MicroPython と C の連携:**
   - MicroPython は FTL の高レベルなポリシー決定やファイルシステムインターフェースに適している。
   - C ユーザーモジュールは、PIO ドライバ、ECC 演算、Dhara HAL および Dhara コアロジックといった性能クリティカルな部分を担当する。
   - FTL は、MicroPython の uos モジュールが認識できるブロックデバイスとして C モジュールから公開されるべきである。
5. **開発アプローチ:**
   - rawnand_test プロジェクト（特にピン配置情報）を参考に、低レベル NAND 通信の確立から始める。
   - PIO ドライバ、ECC モジュール、FTL コンポーネントを段階的に開発し、それぞれ単体テストを行う。
   - 最終的に JISC-SSD 上でシステム全体の統合テストと、特に電源断耐性の検証を徹底的に行う。

戦略的展望:

本検討で概説したアプローチに従うことで、JISC-SSD ボード上で MicroPython から利用可能な、堅牢かつ効率的な NAND フラッシュストレージシステムを構築できる可能性が高い。成功の鍵は、PIO の習熟、正確な ECC 実装、そして MicroPython と C モジュール間の効率的な連携にある。このプロジェクトは、リソース制約のあるマイクロコントローラ上で高度なストレージ管理を実現する上での貴重な知見を提供するだろう。

## **XI. 付録（オプション）**

### **A. Kioxia TC58NVG0S3HTA00 主要コマンド概要**

<table>
  <tr>
   <td><strong>コマンド名</strong>
   </td>
   <td><strong>1st Cycle</strong>
   </td>
   <td><strong>2nd Cycle</strong>
   </td>
  </tr>
  <tr>
   <td>Read (リード)
   </td>
   <td>00h
   </td>
   <td>30h
   </td>
  </tr>
  <tr>
   <td>Serial Data Input (シリアルデータ入力)
   </td>
   <td>80h
   </td>
   <td>-
   </td>
  </tr>
  <tr>
   <td>Column Address Change (列アドレス変更)
   </td>
   <td>05h
   </td>
   <td>E0h
   </td>
  </tr>
  <tr>
   <td>Read with Data Cache (データキャッシュ付きリード)
   </td>
   <td>31h
   </td>
   <td>-
   </td>
  </tr>
  <tr>
   <td>Auto Page Program (オートページプログラム)
   </td>
   <td>80h
   </td>
   <td>10h
   </td>
  </tr>
  <tr>
   <td>Auto Block Erase (オートブロック消去)
   </td>
   <td>60h
   </td>
   <td>D0h
   </td>
  </tr>
  <tr>
   <td>ID Read (IDリード)
   </td>
   <td>90h
   </td>
   <td>-
   </td>
  </tr>
  <tr>
   <td>Status Read (ステータスリード)
   </td>
   <td>70h
   </td>
   <td>-
   </td>
  </tr>
  <tr>
   <td>Reset (リセット)
   </td>
   <td>FFh
   </td>
   <td>-
   </td>
  </tr>
</table>

_出典: <sup>3</sup>_

### **B. NAND 制御のための概念的な PIO コードスニペット（参考）**

以下は、NAND フラッシュ制御の基本的な操作を RP2040 PIO アセンブリでどのように実装できるかを示す概念的なスニペットである。実際のコードは、ピン配置、タイミング、NAND チップの仕様に合わせて調整する必要がある。

**コマンド送信の概念:**

    Python

# PIO アセンブリ (MicroPython シンタックス) \

@rp2.asm_pio(out_init=(rp2.PIO.OUT_LOW,) \* 8, sideset_init=rp2.PIO.OUT_LOW) \
def nand_send_cmd(): \

# CLE = High, ALE = Low (assuming sideset pins) \

# WE pulse \

pull(noblock) # コマンドバイトを OSR へ \
 mov(x, osr) # OSR から X へ（必要なら） \
 set(pins, 0b01) # CLE=1, ALE=0 (仮のピン割り当て).side(0) # WE=0 \
 out(pins, 8) # 8 ビットコマンドを出力.side(1) # WE=1 (パルス開始) \
 nop() # WE パルス幅確保.side(0) # WE=0 (パルス終了) \

**データ読み出しの概念（1 バイト）:**

    Python

# PIO アセンブリ (MicroPython シンタックス) \

@rp2.asm\*pio(in_init=(rp2.PIO.IN_LOW,) \* 8, sideset_init=rp2.PIO.OUT_LOW) \
def nand_read_byte(): \

# CLE = Low, ALE = Low \

# RE pulse \

set(pins, 0b00) # CLE=0, ALE=0.side(0) # RE=0 \
 nop() # RE パルス開始.side(1) # RE=1 \
 in\*(pins, 8) # 8 ビットデータを ISR へ \
 push(noblock) \
 nop() # RE パルス終了.side(0) # RE=0 \

_注意: 上記は非常に簡略化された概念であり、実際の NAND タイミング（tWP, tRP, tCEA など）や R/B ピンの監視は含まれていない。完全な実装には、Kioxia データシート <sup>3</sup> に基づく正確なタイミング制御と状態管理が必要である。_

### **C. BCH ECC ライブラリインターフェース（主要関数シグネチャ例）**

仮に C 言語で BCH ECC ライブラリを使用する場合、以下のような関数シグネチャが考えられる。

    C

// BCH パラメータ構造体 (m, t, 多項式などを含む) \
typedef struct { \
 int m; // ガロア体の次数 GF(2^m) \
 int t; // 訂正可能なエラービット数 \
 int n; // コード長 (ビット単位、データ + ECC) \
 int k; // データ長 (ビット単位) \
 //... その他の内部状態やルックアップテーブルポインタ \
} bch_control_t; \
 \
/\*\* \

- @brief BCH 制御構造体を初期化する \
- @param bch BCH 制御構造体へのポインタ \
- @param m ガロア体の次数 \
- @param t 訂正可能なエラービット数 \
- @param data_len_bytes 保護するデータ長 (バイト単位) \
- @return 0:成功, それ以外:エラー \
   */ \
  int bch_init(bch_control_t *bch, int m, int t, int data_len_bytes); \
   \
  /\*\* \
- @brief データから BCH ECC パリティを計算する \
- @param bch 初期化済み BCH 制御構造体へのポインタ \
- @param data ECC を計算するデータへのポインタ \
- @param ecc_out 計算された ECC パリティを格納するバッファへのポインタ \
   */ \
  void bch_encode(bch_control_t *bch, const unsigned char *data, unsigned char *ecc_out); \
   \
  /\*\* \
- @brief データと ECC パリティを使用してエラーを検出し訂正する \
- @param bch 初期化済み BCH 制御構造体へのポインタ \
- @param data (破損している可能性のある) データへのポインタ。訂正された場合、このバッファは上書きされる。 \
- @param ecc_in 読み出された ECC パリティへのポインタ \
- @return 訂正されたエラービット数。訂正不可能な場合は負の値。 \
   */ \
  int bch_decode(bch_control_t *bch, unsigned char *data, const unsigned char *ecc_in); \
   \
  /\*\* \
- @brief BCH 制御構造体を解放する \
- @param bch BCH 制御構造体へのポインタ \
   */ \
  void bch_free(bch_control_t *bch); \

_注意: これはあくまで概念的なインターフェースであり、実際のライブラリは異なるシグネチャや機能を持つ可能性がある。Kioxia TC58NVG0S3HTA00 の場合、t=8、data_len_bytes=512 となる。m は通常 13 が選択されることが多い。_

#### 引用文献

1. Flash Translation Layer | Efficient Flash Management - Hitex GmbH, 6 月 6, 2025 にアクセス、 [https://www.hitex.com/products/middleware/flash-translation-layer](https://www.hitex.com/products/middleware/flash-translation-layer)
2. Flash Translation Layer Explained - ChemIDP Innovations, 6 月 6, 2025 にアクセス、 [https://chemidp-test.acs.org/flash-translation-layer-explained](https://chemidp-test.acs.org/flash-translation-layer-explained)
3. TC58NVG0S3HTA00 - DigiKey, 6 月 6, 2025 にアクセス、 [https://mm.digikey.com/Volume0/opasdata/d220001/medias/docus/506/KIOXIA_TC58NVG0S3HTA00_Rev2.00_E191001C.pdf](https://mm.digikey.com/Volume0/opasdata/d220001/medias/docus/506/KIOXIA_TC58NVG0S3HTA00_Rev2.00_E191001C.pdf)
4. MicroPython Basics: What is MicroPython? - DigiKey, 6 月 6, 2025 にアクセス、 [https://www.digikey.com/en/maker/projects/micropython-basics-what-is-micropython/1f60afd88e6b44c0beb0784063f664fc](https://www.digikey.com/en/maker/projects/micropython-basics-what-is-micropython/1f60afd88e6b44c0beb0784063f664fc)
5. MicroPython - Python for microcontrollers, 6 月 6, 2025 にアクセス、 [https://micropython.org/](https://micropython.org/)
6. RP2040 Doom | rp2040-doom - GitHub Pages, 6 月 6, 2025 にアクセス、 [https://kilograham.github.io/rp2040-doom/speed_and_ram.html](https://kilograham.github.io/rp2040-doom/speed_and_ram.html)
7. D-Buckingham/NAND_flash: Zephyr RTOS Nand Flash implementation FTL Dhara - GitHub, 6 月 6, 2025 にアクセス、 [https://github.com/D-Buckingham/NAND_flash](https://github.com/D-Buckingham/NAND_flash)
8. dlbeer/dhara: NAND flash translation layer for low-memory ... - GitHub, 6 月 6, 2025 にアクセス、 [https://github.com/dlbeer/dhara](https://github.com/dlbeer/dhara)
9. Discussion: littlefs on SPI NAND · Issue #11 - GitHub, 6 月 6, 2025 にアクセス、 [https://github.com/littlefs-project/littlefs/issues/11](https://github.com/littlefs-project/littlefs/issues/11)
10. Managed Flash Background Operations Series Part 3: Understanding Wear Leveling in NAND Flash Memory - KIOXIA, 6 月 6, 2025 にアクセス、 [https://americas.kioxia.com/content/dam/kioxia/en-us/business/memory/mlc-nand/asset/KIOXIA_Managed_Flash_BOS_P3_Understanding_Wear_Leveling_Tech_Brief.pdf](https://americas.kioxia.com/content/dam/kioxia/en-us/business/memory/mlc-nand/asset/KIOXIA_Managed_Flash_BOS_P3_Understanding_Wear_Leveling_Tech_Brief.pdf)
11. Wear leveling - Wikipedia, 6 月 6, 2025 にアクセス、 [https://en.wikipedia.org/wiki/Wear_leveling](https://en.wikipedia.org/wiki/Wear_leveling)
12. Bad Block Management - Transcend Information, Inc., 6 月 6, 2025 にアクセス、 [https://www.transcend-info.com/embedded/technology/bad-block-management](https://www.transcend-info.com/embedded/technology/bad-block-management)
13. Understanding Bad Block Management in NAND Flash Memory - KIOXIA America, Inc., 6 月 6, 2025 にアクセス、 [https://americas.kioxia.com/content/dam/kioxia/en-us/business/memory/mlc-nand/asset/KIOXIA_Managed_Flash_BOS_P2_Understanding_Bad_Block_Management_Tech_Brief.pdf](https://americas.kioxia.com/content/dam/kioxia/en-us/business/memory/mlc-nand/asset/KIOXIA_Managed_Flash_BOS_P2_Understanding_Bad_Block_Management_Tech_Brief.pdf)
14. Understanding Garbage Collection in NAND Flash Memory, 6 月 6, 2025 にアクセス、 [https://americas.kioxia.com/content/dam/kioxia/en-us/business/memory/mlc-nand/asset/KIOXIA_Managed_Flash_BOS_P4_Understanding_Garbage_Collection_Tech_Brief.pdf](https://americas.kioxia.com/content/dam/kioxia/en-us/business/memory/mlc-nand/asset/KIOXIA_Managed_Flash_BOS_P4_Understanding_Garbage_Collection_Tech_Brief.pdf)
15. Garbage Collection - SMART Modular Technologies, 6 月 6, 2025 にアクセス、 [https://www.smartm.com/technology/garbage-collection](https://www.smartm.com/technology/garbage-collection)
16. LazyFTL: A Page-level Flash Translation Layer Optimized for NAND Flash Memory - Database Group, 6 月 6, 2025 にアクセス、 [https://dbgroup.cs.tsinghua.edu.cn/ligl/papers/sigmod2011-lazyftl.pdf](https://dbgroup.cs.tsinghua.edu.cn/ligl/papers/sigmod2011-lazyftl.pdf)
17. RP2040 - Wikipedia, 6 月 6, 2025 にアクセス、 [https://en.wikipedia.org/wiki/RP2040](https://en.wikipedia.org/wiki/RP2040)
18. Embedded Flash Memory, 6 月 6, 2025 にアクセス、 [https://my.stage.avnet.com/wcm/connect/f6654e9b-a0e2-4424-80ca-8928280e5c8c/KIOXIA+Embedded+Flash+Memory+Brochure.pdf?MOD=AJPERES&ContentCache=NONE&CACHE=NONE&CVID=oW06hid](https://my.stage.avnet.com/wcm/connect/f6654e9b-a0e2-4424-80ca-8928280e5c8c/KIOXIA+Embedded+Flash+Memory+Brochure.pdf?MOD=AJPERES&ContentCache=NONE&CACHE=NONE&CVID=oW06hid)
19. JISC-SSD(Jisaku In-Storage Computation SSD 学習ボード ..., 6 月 6, 2025 にアクセス、 [https://www.switch-science.com/products/8415](https://www.switch-science.com/products/8415)
20. RP2040-Plus with header, 16MB Flash memory - Pi-Shop.ch, 6 月 6, 2025 にアクセス、 [https://www.pi-shop.ch/rp2040-plus-with-header-16mb-flash-memory](https://www.pi-shop.ch/rp2040-plus-with-header-16mb-flash-memory)
21. RP2040 Datasheet - CBA, 6 月 6, 2025 にアクセス、 [http://academy.cba.mit.edu/classes/embedded_programming/RP2040/RP2040.pdf](http://academy.cba.mit.edu/classes/embedded_programming/RP2040/RP2040.pdf)
22. RP2040-Zero - Waveshare Wiki, 6 月 6, 2025 にアクセス、 [https://www.waveshare.com/wiki/RP2040-Zero](https://www.waveshare.com/wiki/RP2040-Zero)
23. Programmable IO Programming - Circuit Cellar, 6 月 6, 2025 にアクセス、 [https://circuitcellar.com/research-design-hub/basics-of-design/programmable-io-programming/](https://circuitcellar.com/research-design-hub/basics-of-design/programmable-io-programming/)
24. A Reconfigurable FTL (Flash Translation Layer) Architecture for NAND Flash-Based Applications - CiteSeerX, 6 月 6, 2025 にアクセス、 [https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=fde958d2bf144cb200ed86deb20f92734654e0ab](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=fde958d2bf144cb200ed86deb20f92734654e0ab)
25. crane-elec/rawnand_test: Raw NAND Flash Memory test for ... - GitHub, 6 月 6, 2025 にアクセス、 [https://github.com/crane-elec/rawnand_test](https://github.com/crane-elec/rawnand_test)
26. 1 月 1, 1970 にアクセス、 [https://github.com/crane-elec/rawnand_test/blob/main/RawNAND_Pico_pinout.xlsx](https://github.com/crane-elec/rawnand_test/blob/main/RawNAND_Pico_pinout.xlsx)
27. Raspberry Pi Pico and RP2040 - MicroPython Part 3: PIO - DigiKey, 6 月 6, 2025 にアクセス、 [https://www.digikey.com/en/maker/projects/raspberry-pi-pico-and-rp2040-micropython-part-3-pio/3079f9f9522743d09bb65997642e0831](https://www.digikey.com/en/maker/projects/raspberry-pi-pico-and-rp2040-micropython-part-3-pio/3079f9f9522743d09bb65997642e0831)
28. RP2040 Programmable IO - Circuit Cellar, 6 月 6, 2025 にアクセス、 [https://circuitcellar.com/resources/quickbits/rp2040-programmable-io/](https://circuitcellar.com/resources/quickbits/rp2040-programmable-io/)
29. rp2 — functionality specific to the RP2040 — MicroPython latest documentation, 6 月 6, 2025 にアクセス、 [https://docs.micropython.org/en/latest/library/rp2.html](https://docs.micropython.org/en/latest/library/rp2.html)
30. Programmable IO — MicroPython latest documentation, 6 月 6, 2025 にアクセス、 [https://docs.micropython.org/en/latest/rp2/tutorial/pio.html](https://docs.micropython.org/en/latest/rp2/tutorial/pio.html)
31. MicroPython libraries — MicroPython latest documentation, 6 月 6, 2025 にアクセス、 [https://docs.micropython.org/en/latest/library/index.html](https://docs.micropython.org/en/latest/library/index.html)
32. uos – basic “operating system” services - MicroPython documentation, 6 月 6, 2025 にアクセス、 [https://docs.micropython.org/en/v1.16/library/uos.html](https://docs.micropython.org/en/v1.16/library/uos.html)
33. Learning RP2040 PIO with Camera Remote Controls - element14 Community, 6 月 6, 2025 にアクセス、 [https://community.element14.com/products/raspberry-pi/raspberrypi_projects/b/blog/posts/learning-rp2040-pio-with-camera-remote-controls](https://community.element14.com/products/raspberry-pi/raspberrypi_projects/b/blog/posts/learning-rp2040-pio-with-camera-remote-controls)
34. Micropython on PICO, C extension on a new directory - Raspberry Pi Forums, 6 月 6, 2025 にアクセス、 [https://forums.raspberrypi.com/viewtopic.php?t=383714](https://forums.raspberrypi.com/viewtopic.php?t=383714)
35. dhara/dhara/nand.h at master · dlbeer/dhara - GitHub, 6 月 6, 2025 にアクセス、 [https://github.com/dlbeer/dhara/blob/master/dhara/nand.h](https://github.com/dlbeer/dhara/blob/master/dhara/nand.h)
36. NAND Error Correction Codes Introduction - Macronix, 6 月 6, 2025 にアクセス、 [https://www.macronix.com/Lists/ApplicationNote/Attachments/1910/AN0271V1-NAND%20Error%20Correction%20Codes%20Introduction-0217.pdf](https://www.macronix.com/Lists/ApplicationNote/Attachments/1910/AN0271V1-NAND%20Error%20Correction%20Codes%20Introduction-0217.pdf)
37. bch/lib/bch.c at master · Parrot-Developers/bch - GitHub, 6 月 6, 2025 にアクセス、 [https://github.com/Parrot-Developers/bch/blob/master/lib/bch.c](https://github.com/Parrot-Developers/bch/blob/master/lib/bch.c)
38. BCH ECC decoder for Qualcomm NAND controller - GitHub Gist, 6 月 6, 2025 にアクセス、 [https://gist.github.com/llccd/86a225f57700cd54d4d1676bd29eed5a](https://gist.github.com/llccd/86a225f57700cd54d4d1676bd29eed5a)
39. ak-hard/brcm-nand-bch: Software BCH ECC generation for Broadcom SOC NAND controllers. - GitHub, 6 月 6, 2025 にアクセス、 [https://github.com/ak-hard/brcm-nand-bch](https://github.com/ak-hard/brcm-nand-bch)
40. "Nine Pico PIO Wats with MicroPython (Part 1)" - Raspberry Pi Forums, 6 月 6, 2025 にアクセス、 [https://forums.raspberrypi.com/viewtopic.php?t=382968](https://forums.raspberrypi.com/viewtopic.php?t=382968)
